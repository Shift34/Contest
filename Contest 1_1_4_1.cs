У вас есть перестановка — массив a=[a1,a2,…,an] из различных целых чисел от 1 до n.

Рассмотрим следующий алгоритм сортировки перестановки по возрастанию.

Вспомогательная процедура алгоритма, f(i), принимает на вход индекс i (1 ≤ i ≤ n−1) и делает следующее. 

Если ai > ai+1, значения ai и ai+1 меняются местами. В противном случае перестановка остаётся без изменений.

Алгоритм состоит из итераций, пронумерованных последовательными целыми числами, начиная с 1. На i-й итерации алгоритм делает следующее:

если i нечётно, вызываются f(1),f(3),…,f(n−1);

если i чётно, вызываются f(2),f(4),…,f(n−1).

Можно доказать, что после конечного числа итераций перестановка станет отсортирована по возрастанию.

Через сколько итераций это впервые произойдёт?

Формат ввода
Во входных данных находятся несколько наборов входных данных. 

В первой строке находится одно целое число t (1≤t≤100) — количество наборов входных данных. Далее следуют наборы входных данных.

Первая строка набора входных данных содержит одно целое число n (3 ≤ n ≤ 999; n нечётно) — длину перестановки.

Вторая строка содержит n различных целых чисел a1,a2,…,an (1 ≤ ai ≤ n) — саму перестановку.

Гарантируется, что сумма значений n по всем наборам входных данных не превосходит 999.

Формат вывода
Для каждого набора входных данных выведите число итераций, после которого заданная перестановка впервые окажется отсортирована по возрастанию.

Если заданная перестановка уже отсортирована, выведите 0.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp456
{
    class Program
    {
        private static int f;
        private static int y;

        static void Main(string[] args)
        {
            int n = int.Parse(Console.ReadLine());
            int z = 0;
            int q = 0;
            int[] l = new int[n];
            for (int i = 0; i < n; i++)
            {
                int f = int.Parse(Console.ReadLine());
                int iterations = 0;
                int[] ff = new int[f];
                string[] kk = Console.ReadLine().Split();
                for (int y = 0; y < f; y++)
                {                        
                    ff[y] = int.Parse(kk[y]);
                }
                q = 0;
                for (int y = 0; y < f ;y++)
                {
                        z = 0;
                        if (y%2==0) 
                        for (int j = 0; j < f- 1; j += 2)
                        {
                                    if (ff[j] > ff[j+1])
                                    {
                                       int temp = ff[j + 1];
                                       ff[j + 1] = ff[j];
                                       ff[j] = temp;
                                       z += 1;
                                    }
                        }
                        if ((y == 0) && (z == 0)) q = 1;
                        if (y%2==1) 
                        for (int j = 1; j < f - 1; j += 2)
                        {
                                     if (ff[j] > ff[j + 1])
                                     {
                                        int temp = ff[j + 1];
                                        ff[j + 1] = ff[j];
                                        ff[j] = temp;
                                        z += 1;
                                     }
                        }
                    if (z > 0) iterations += 1;
                }
                if (iterations > 0) iterations = iterations + q;
                l[i] = iterations;
            }        
            for (int u = 0; u < n; u++)
            {
                Console.WriteLine(l[u]);
            }
            Console.ReadKey();            
        }
    }
}
