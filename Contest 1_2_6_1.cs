К тупику со стороны пути 1 (см. рисунок) подъехал поезд. 
Разрешается отцепить от поезда один или сразу несколько первых вагонов и завезти их в тупик (при желании, можно даже завезти в тупик сразу весь поезд).
После этого часть из этих вагонов вывезти в сторону пути 2. 
После этого можно завезти в тупик еще несколько вагонов и снова часть оказавшихся вагонов вывезти в сторону пути 2. 
И так далее (так, что каждый вагон может лишь один раз заехать с пути 1 в тупик, а затем один раз выехать из тупика на путь 2). 
Заезжать в тупик с пути 2 или выезжать из тупика на путь 1 запрещается. Нельзя с пути 1 попасть на путь 2, не заезжая в тупик.


Известно, в каком порядке изначально идут вагоны поезда. 
Требуется с помощью указанных операций сделать так, чтобы вагоны поезда шли по порядку (сначала первый, потом второй и т.д., считая от головы поезда, едущего по пути 2 в сторону от тупика).

Формат ввода
Вводится число N — количество вагонов в поезде (1≤N≤2000). 
Дальше идут номера вагонов в порядке от головы поезда, едущего по пути 1 в сторону тупика. 
Вагоны пронумерованы натуральными числами от 1 до N, каждое из которых встречается ровно один раз.

Формат вывода
Если сделать так, чтобы вагоны шли в порядке от 1 до N, считая от головы поезда, когда поезд поедет по пути 2 из тупика, можно, выведите действия, которые нужно проделать с поездом. 
Каждое действие описывается двумя числами: типом и количеством вагонов:

- если нужно завезти с пути 1 в тупик K вагонов, должно быть выведено сначала число 1, а затем — число K (K≥1),

- если нужно вывезти из тупика на путь 2 K вагонов, должно быть выведено сначала число 2, а затем — число K (K≥1).

Если возможно несколько последовательностей действий, приводящих к нужному результату, выведите любую из них.

Если выстроить вагоны по порядку невозможно, выведите одно число 0.






using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace ConsoleApp135
{
    class Program
    {
        static void Main(string[] args)
        {
            int kim = 1;
            int n = int.Parse(Console.ReadLine());
            int y = 99;
            Stack<int> stack = new Stack<int>();
            Queue<int> queue = new Queue<int>();
            string[] kk = Console.ReadLine().Split();
            for (int i = 0; i < n; i++)
            {
                int value = int.Parse(kk[i]);
                if (stack.Count>0 && value > stack.Peek())
                {
                    y = 0;
                    Console.WriteLine(0);
                    break;
                }
                queue.Enqueue(1);
                stack.Push(value);
                while (stack.Count > 0 && stack.Peek() == kim)
                {
                    queue.Enqueue(2);
                    stack.Pop();
                    kim++;
                }
            }
            if (y != 0)
            {
                int jh = queue.Peek();
                queue.Dequeue();
                int count = 1;
                while (queue.Count > 0)
                {
                    if (queue.Peek() == jh)
                    {
                        count++;
                    }
                    else
                    {
                        Console.WriteLine(jh + " " + count);
                        jh = queue.Peek();
                        count = 1;
                    }
                    queue.Dequeue();
                }
                Console.WriteLine(jh + " " + count);
            }
        }
    }
}
